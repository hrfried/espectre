<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPectre Real-Time Monitor</title>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <!-- MQTT.js -->
    <script src="https://unpkg.com/mqtt@5.3.0/dist/mqtt.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .card.compact {
            padding: 12px 20px;
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapsible-header h2 {
            margin: 0;
            font-size: 1.2em;
        }

        .collapsible-content {
            margin-top: 15px;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
            font-size: 0.9em;
        }

        .input-group input {
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-sm {
            padding: 6px 15px;
            font-size: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-info {
            background: #3498db;
            color: white;
        }

        .btn-info:hover {
            background: #2980b9;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #2ecc71;
        }

        .status-indicator.disconnected {
            background: #e74c3c;
            animation: none;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .metric-card {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s;
        }

        .metric-card:hover {
            transform: translateY(-3px);
        }

        .metric-card.idle {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .metric-card.motion {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .metric-card.neutral {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .metric-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .chart-container {
            position: relative;
            height: 600px;
            margin-bottom: 10px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 1.3em;
            margin: 0;
        }

        .arrow {
            transition: transform 0.3s;
            font-size: 0.9em;
        }

        .arrow.rotate {
            transform: rotate(180deg);
        }

        /* Toggle Switch Styles */
        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            gap: 10px;
        }

        .toggle-label input[type="checkbox"] {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            transition: background 0.3s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
        }

        .toggle-label input[type="checkbox"]:checked+.toggle-slider {
            background: #667eea;
        }

        .toggle-label input[type="checkbox"]:checked+.toggle-slider::before {
            transform: translateX(24px);
        }

        .toggle-text {
            font-weight: 600;
            color: #333;
        }

        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .notification.success {
            background: #2ecc71;
        }

        .notification.error {
            background: #e74c3c;
        }

        .notification.info {
            background: #3498db;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 25px;
            width: 400px;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: scaleIn 0.3s ease-out;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            color: #667eea;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-reload {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            color: #667eea;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .modal-reload:hover {
            background: #667eea15;
            transform: scale(1.1);
        }

        .modal-reload.spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-body {
            font-family: monospace;
            font-size: 0.95em;
            line-height: 1.6;
            color: #333;
        }

        .stat-section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e8e8e8;
        }

        .stat-section:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }

        .stat-section-title {
            font-size: 0.85em;
            font-weight: 600;
            color: #999;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-line {
            padding: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .stat-line:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 500;
            color: #666;
            font-size: 1em;
            flex-shrink: 0;
        }

        .stat-value {
            color: #333;
            font-weight: 600;
            font-size: 1em;
            text-align: right;
            word-break: break-word;
        }

        .stat-value.highlight {
            color: #667eea;
        }

        .stat-value.success {
            color: #2ecc71;
        }

        .stat-value.warning {
            color: #f39c12;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.9);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üõú ESPectre üëª</h1>
            <p>Real-Time Motion Detection Visualization</p>
        </div>

        <!-- MQTT Configuration Card -->
        <div class="card compact">
            <div class="collapsible-header" onclick="toggleConfig()" style="display: flex; align-items: center; gap: 15px;">
                <h2 style="margin: 0;">‚öôÔ∏è MQTT Configuration</h2>
                <div class="status-item" style="margin-left: auto;">
                    <div class="status-indicator disconnected" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <span class="arrow" id="configArrow">‚ñº</span>
            </div>
            <div class="collapsible-content" id="configContent">
                <div class="config-section">
                    <div class="input-group">
                        <label for="broker">Broker Address</label>
                        <input type="text" id="broker" placeholder="homeassistant.local" value="homeassistant.local">
                    </div>
                    <div class="input-group">
                        <label for="port">WebSocket Port</label>
                        <input type="number" id="port" placeholder="9001" value="9001">
                    </div>
                    <div class="input-group">
                        <label for="topic">Topic</label>
                        <input type="text" id="topic" placeholder="home/espectre/node1" value="home/espectre/node1">
                    </div>
                    <div class="input-group">
                        <label for="username">Username (optional)</label>
                        <input type="text" id="username" placeholder="user" value="mqtt">
                    </div>
                    <div class="input-group">
                        <label for="password">Password (optional)</label>
                        <input type="password" id="password" placeholder="password" value="mqtt">
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">Connect</button>
                    <button class="btn btn-danger" id="clearBtn" onclick="clearData()" style="display: none;">Clear Data</button>
                </div>
            </div>
        </div>

        <!-- ESPectre Configuration -->
        <div class="card">
            <div class="collapsible-header" onclick="toggleSection('configuration')">
                <h2>üõú ESPectre Configuration</h2>
                <span class="arrow rotate" id="configurationArrow">‚ñº</span>
            </div>
            <div class="collapsible-content collapsed" id="configurationContent">
                <!-- Device & Network Information -->
                <div style="background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); border-left: 4px solid #667eea; border-radius: 8px; margin-bottom: 20px; padding: 15px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                        <span style="font-size: 1.3em;">üì±</span>
                        <span style="font-weight: 700; color: #667eea; font-size: 1.1em;">Device & Network Information</span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; font-size: 0.95em;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üñ•Ô∏è</span>
                            <span style="font-weight: 600; color: #666;">Device:</span>
                            <span id="deviceType" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üì°</span>
                            <span style="font-weight: 600; color: #666;">IP:</span>
                            <span id="deviceIP" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üîó</span>
                            <span style="font-weight: 600; color: #666;">MAC:</span>
                            <span id="deviceMAC" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üìª</span>
                            <span style="font-weight: 600; color: #666;">Channel:</span>
                            <span id="wifiChannel" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üì∂</span>
                            <span style="font-weight: 600; color: #666;">Bandwidth:</span>
                            <span id="wifiBandwidth" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üì°</span>
                            <span style="font-weight: 600; color: #666;">Protocol:</span>
                            <span id="wifiProtocol" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.1em;">üëÅÔ∏è</span>
                            <span style="font-weight: 600; color: #666;">Promiscuous:</span>
                            <span id="wifiPromiscuous" style="font-family: monospace; color: #333; font-weight: 600;">-</span>
                        </div>
                    </div>
                </div>

                <!-- Detection Parameters Section -->
                <div
                    style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                    <div class="collapsible-header" onclick="toggleSubSection('detectionParams')"
                        style="padding: 5px 0;">
                        <h3
                            style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üéØ</span> Detection Parameters
                        </h3>
                        <span class="arrow" id="detectionParamsArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content" id="detectionParamsContent" style="margin-top: 15px;">
                        <div
                            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label for="trafficRate" style="font-size: 0.85em;">üì° WiFi Packet Rate (0-1000 Hz)</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="range" id="trafficRate" min="0" max="1000" step="1" value="100"
                                        style="flex: 1;">
                                    <input type="number" id="trafficRateValue" min="0" max="1000" step="1" value="100"
                                        style="width: 70px; padding: 6px; font-size: 0.9em;">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">How many WiFi packets to send per second.<br>0 = disabled (uses ambient WiFi traffic only).<br>Increase to improve precision at the cost of bandwidth and CPU.<br><b>Recommended: 100 Hz for normal use üí°</b></small>
                            </div>
                            <div class="input-group">
                                <label for="windowSize" style="font-size: 0.85em;">‚ö° Response Speed (10-200)</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="range" id="windowSize" min="10" max="200" step="1" value="50"
                                        style="flex: 1;">
                                    <input type="number" id="windowSizeValue" min="10" max="200" step="1" value="50"
                                        style="width: 70px; padding: 6px; font-size: 0.9em;">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">How fast the system reacts to changes.<br>Low value = quick response, more sensitive to noise.<br>High value = stable, filters out small variations.<br><b>Recommended: 50 üí°</b></small>
                            </div>
                            <div class="input-group">
                                <label for="segThreshold" style="font-size: 0.85em;">üéØ Motion Threshold (0.5-10.0)</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="range" id="segThreshold" min="0.5" max="10.0" step="0.1" value="3.0"
                                        style="flex: 1;">
                                    <input type="number" id="segThresholdValue" min="0.5" max="10.0" step="0.1"
                                        value="3.0" style="width: 70px; padding: 6px; font-size: 0.9em;">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Minimum threshold required to detect movement.<br>Low value = detects small movements.<br>High value = detects large movements.<br><b>Recommended: 3.0 for balanced detection üí°</b></small>
                            </div>
                            <div id="subcarrierSelectionContent" style="grid-column: span 3;">
                                <div class="input-group">
                                    <label for="subcarrierIndices" style="font-size: 0.85em;">üìª WiFi Channel Selection (0-63)</label>
                                    <input type="text" id="subcarrierIndices" placeholder="47,48,49,50,51,52,53,54,55,56,57,58"
                                        style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: monospace; width: 100%;">
                                    <small style="color: #666; font-size: 0.8em;">Choose which WiFi frequency channels to monitor (comma-separated). <b>Default selection works well for most cases üí°</b></small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Feature Parameters Section -->
                <div id="featureParametersSection"
                    style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0; display: none;">
                    <div class="collapsible-header" onclick="toggleSubSection('featuresFilters')"
                        style="padding: 5px 0;">
                        <h3
                            style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üî¨</span> Feature Parameters
                        </h3>
                        <span class="arrow" id="featuresFiltersArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content" id="featuresFiltersContent" style="margin-top: 15px;">
                        <!-- Features Extraction Toggle -->
                        <div
                            style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div class="toggle-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="featuresEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text" style="font-size: 0.95em;">üî¨ Advanced Feature Extraction</span>
                                </label>
                                <small style="color: #666; font-size: 0.85em;">Extract detailed motion characteristics during detection<br>üí° Enable for machine learning and advanced analysis</small>
                            </div>
                        </div>

                        <!-- Filters Grid -->
                        <h4
                            style="margin: 0 0 12px 0; color: #667eea; font-size: 1em; display: flex; align-items: center; gap: 6px;">
                            <span>üîß</span> Signal Filters
                        </h4>
                        <div
                            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px;">
                            <!-- Hampel Filter -->
                            <div
                                style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: white;">
                                <div class="toggle-group" style="margin-bottom: 10px;">
                                    <label class="toggle-label">
                                        <input type="checkbox" id="hampelFilter">
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-text" style="font-size: 0.9em;">üéØ Spike Remover</span>
                                    </label>
                                    <small style="color: #666; font-size: 0.8em;">Removes sudden anomalies and spikes<br>Good for: Eliminating interference</small>
                                </div>
                                <div class="input-group">
                                    <label for="hampelThreshold" style="font-size: 0.8em;">Sensitivity (1.0-10.0)</label>
                                    <div style="display: flex; gap: 6px; align-items: center;">
                                        <input type="range" id="hampelThreshold" min="1.0" max="10.0" step="0.1"
                                            value="2.0" style="flex: 1;">
                                        <input type="number" id="hampelThresholdValue" min="1.0" max="10.0" step="0.1"
                                            value="2.0" style="width: 60px; padding: 4px; font-size: 0.85em;">
                                    </div>
                                    <small style="color: #666; font-size: 0.75em;">Lower = more aggressive filtering</small>
                                </div>
                            </div>

                            <!-- Savitzky-Golay Filter -->
                            <div
                                style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: white;">
                                <div class="toggle-group">
                                    <label class="toggle-label">
                                        <input type="checkbox" id="savgolFilter">
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-text" style="font-size: 0.9em;">üìä Signal Smoother</span>
                                    </label>
                                    <small style="color: #666; font-size: 0.8em;">Smooths signal while preserving shape<br>Good for: Reducing jitter and noise</small>
                                </div>
                            </div>

                            <!-- Butterworth Filter -->
                            <div
                                style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: white;">
                                <div class="toggle-group">
                                    <label class="toggle-label">
                                        <input type="checkbox" id="butterworthFilter">
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-text" style="font-size: 0.9em;">üîá Noise Filter</span>
                                    </label>
                                    <small style="color: #666; font-size: 0.8em;">Removes high-frequency noise<br>Good for: Cleaner signal in noisy environments</small>
                                </div>
                            </div>

                            <!-- Wavelet Filter -->
                            <div
                                style="padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; background: white;">
                                <div class="toggle-group" style="margin-bottom: 10px;">
                                    <label class="toggle-label">
                                        <input type="checkbox" id="waveletFilter">
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-text" style="font-size: 0.9em;">üåä Background Remover</span>
                                    </label>
                                    <small style="color: #666; font-size: 0.8em;">Removes slow background changes<br>Good for: Focusing on actual motion</small>
                                </div>
                                <div class="input-group" style="margin-bottom: 8px;">
                                    <label for="waveletLevel" style="font-size: 0.8em;">Depth (1-3)</label>
                                    <div style="display: flex; gap: 6px; align-items: center;">
                                        <input type="range" id="waveletLevel" min="1" max="3" step="1" value="3"
                                            style="flex: 1;">
                                        <input type="number" id="waveletLevelValue" min="1" max="3" step="1" value="3"
                                            style="width: 60px; padding: 4px; font-size: 0.85em;">
                                    </div>
                                    <small style="color: #666; font-size: 0.75em;">Higher = more thorough filtering</small>
                                </div>
                                <div class="input-group">
                                    <label for="waveletThreshold" style="font-size: 0.8em;">Strength (0.5-2.0)</label>
                                    <div style="display: flex; gap: 6px; align-items: center;">
                                        <input type="range" id="waveletThreshold" min="0.5" max="2.0" step="0.1"
                                            value="1.0" style="flex: 1;">
                                        <input type="number" id="waveletThresholdValue" min="0.5" max="2.0" step="0.1"
                                            value="1.0" style="width: 60px; padding: 4px; font-size: 0.85em;">
                                    </div>
                                    <small style="color: #666; font-size: 0.75em;">Higher = stronger filtering</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Global Action Buttons -->
                <div
                    style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; padding-top: 10px; border-top: 2px solid #e0e0e0;">
                    <button class="btn btn-info" id="smartPublishingBtn" onclick="toggleSmartPublishing()">Smart
                        Publishing: ON</button>
                    <button class="btn btn-warning" onclick="requestInfo()">Reload info</button>
                    <button class="btn btn-success btn-sm" onclick="requestStats()">Statistics</button>
                    <button class="btn btn-danger" onclick="factoryReset()">Factory Reset</button>
                </div>
            </div>
        </div>

        <!-- Metrics Cards (Fixed) -->
        <div class="card compact">
            <div class="metrics-grid">
                <div class="metric-card idle" id="stateCard">
                    <div class="metric-label">State</div>
                    <div class="metric-value" id="stateValue">-</div>
                </div>
                <div class="metric-card neutral">
                    <div class="metric-label">Movement</div>
                    <div class="metric-value" id="movementValue">-</div>
                </div>
                <div class="metric-card neutral">
                    <div class="metric-label">Messages</div>
                    <div class="metric-value" id="messageCount">0</div>
                </div>
                <div class="metric-card neutral">
                    <div class="metric-label">Last Update</div>
                    <div class="metric-value" id="lastUpdate">-</div>
                </div>
            </div>
        </div>

        <!-- Chart  (Fixed) -->
        <div class="card">
            <div class="chart-header">
                <h2 class="chart-title" id="chartTitle">üìà Real-Time Chart</h2>
                <button class="btn btn-warning btn-sm" id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
            </div>
            <div class="chart-container">
                <canvas id="motionChart"></canvas>
            </div>
        </div>

    </div>

    <script>
        let client = null;
        let chart = null;
        let messageCount = 0;
        let maxDataPoints = 60;
        let currentFeatures = null;
        let isPaused = false;
        let pendingData = [];
        let smartPublishingEnabled = true; // Track smart publishing state

        const chartData = {
            labels: [],
            movement: [],
            threshold: [],
            features: [],
            packets_processed: [],
            packets_dropped: []
        };

        // Initialize Chart
        function initChart() {
            const ctx = document.getElementById('motionChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [
                        {
                            label: 'Movement',
                            data: chartData.movement,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Threshold',
                            data: chartData.threshold,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            tension: 0,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'CSI Packets',
                            data: chartData.packets_processed,
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'CSI Dropped',
                            data: chartData.packets_dropped,
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 300
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Movement / Threshold'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'CSI Packets/sec'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                afterBody: function (context) {
                                    const index = context[0].dataIndex;
                                    const features = chartData.features[index];

                                    const lines = [''];

                                    // Show features only if available
                                    if (features) {
                                        lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                                        lines.push('üî¨ Extracted Features:');
                                        lines.push('');
                                        lines.push(`Variance: ${features.variance?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Skewness: ${features.skewness?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Kurtosis: ${features.kurtosis?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Entropy: ${features.entropy?.toFixed(3) || 'N/A'}`);
                                        lines.push(`IQR: ${features.iqr?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Spatial Variance: ${features.spatial_variance?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Spatial Correlation: ${features.spatial_correlation?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Spatial Gradient: ${features.spatial_gradient?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Temporal Delta Mean: ${features.temporal_delta_mean?.toFixed(3) || 'N/A'}`);
                                        lines.push(`Temporal Delta Variance: ${features.temporal_delta_variance?.toFixed(3) || 'N/A'}`);
                                    }

                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            const chartTitle = document.getElementById('chartTitle');

            if (isPaused) {
                pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
                pauseBtn.classList.remove('btn-warning');
                pauseBtn.classList.add('btn-success');
                chartTitle.textContent = 'üìà Real-Time Chart (PAUSED)';
            } else {
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                pauseBtn.classList.remove('btn-success');
                pauseBtn.classList.add('btn-warning');
                chartTitle.textContent = 'üìà Real-Time Chart';

                // Add all pending data when resuming
                if (pendingData.length > 0) {
                    pendingData.forEach(data => addDataToChart(data));
                    pendingData = [];
                }
            }
        }

        function toggleConfig() {
            const content = document.getElementById('configContent');
            const arrow = document.getElementById('configArrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        function toggleConnection() {
            if (client && client.connected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const broker = document.getElementById('broker').value;
            const port = document.getElementById('port').value;
            const topic = document.getElementById('topic').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!broker || !port || !topic) {
                alert('Please fill in all required fields!');
                return;
            }

            const connectUrl = `ws://${broker}:${port}/mqtt`;

            const options = {
                clean: true,
                connectTimeout: 4000,
                clientId: 'espectre_monitor_' + Math.random().toString(16).substr(2, 8)
            };

            if (username) options.username = username;
            if (password) options.password = password;

            try {
                client = mqtt.connect(connectUrl, options);

                client.on('connect', () => {
                    console.log('Connected to MQTT broker');
                    updateStatus(true);
                    document.getElementById('configContent').classList.add('collapsed');
                    document.getElementById('configArrow').classList.add('rotate');

                    // Subscribe to main topic
                    client.subscribe(topic, (err) => {
                        if (err) {
                            console.error('Subscribe error:', err);
                            alert('Error subscribing to topic!');
                        } else {
                            console.log('Subscribed to:', topic);
                        }
                    });

                    // Also subscribe to response topic
                    const responseTopic = topic + '/response';
                    client.subscribe(responseTopic, (err) => {
                        if (err) {
                            console.error('Subscribe error for response topic:', err);
                        } else {
                            console.log('Subscribed to:', responseTopic);

                            // Request current configuration after successful connection
                            setTimeout(() => {
                                console.log('Requesting initial configuration...');
                                requestInfo();
                            }, 500); // Small delay to ensure subscriptions are ready
                        }
                    });
                });

                client.on('message', (topic, message) => {
                    // Text message - parse as JSON
                    handleMessage(message.toString());
                });

                client.on('error', (err) => {
                    console.error('Connection error:', err);
                    alert('Connection error: ' + err.message);
                    updateStatus(false);
                });

                client.on('close', () => {
                    console.log('Connection closed');
                    updateStatus(false);
                });

            } catch (err) {
                console.error('Connection error:', err);
                alert('Connection error: ' + err.message);
            }
        }

        function disconnect() {
            if (client) {
                client.end();
                client = null;
                updateStatus(false);
            }
        }

        function updateStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const clearBtn = document.getElementById('clearBtn');

            if (connected) {
                indicator.classList.remove('disconnected');
                indicator.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.textContent = 'Disconnect';
                connectBtn.classList.remove('btn-primary');
                connectBtn.classList.add('btn-danger');
                clearBtn.style.display = 'inline-block';
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
                statusText.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                connectBtn.classList.remove('btn-danger');
                connectBtn.classList.add('btn-primary');
                clearBtn.style.display = 'none';
            }
        }


        function addDataToChart(data) {
            const now = new Date();
            const timeLabel = now.toLocaleTimeString('en-US');

            chartData.labels.push(timeLabel);
            chartData.movement.push(data.movement || 0);
            chartData.threshold.push(data.threshold || 0);
            chartData.features.push(data.features || null);
            chartData.packets_processed.push(data.packets_processed || 0);
            chartData.packets_dropped.push(data.packets_dropped || 0);

            if (chartData.labels.length > maxDataPoints) {
                chartData.labels.shift();
                chartData.movement.shift();
                chartData.threshold.shift();
                chartData.features.shift();
                chartData.packets_processed.shift();
                chartData.packets_dropped.shift();
            }

            chart.update('none');
        }

        function updateMetrics(data) {
            const stateCard = document.getElementById('stateCard');
            const stateValue = document.getElementById('stateValue');
            stateValue.textContent = data.state === 'motion' ? 'MOTION' : 'IDLE';

            if (data.state === 'motion') {
                stateCard.classList.remove('idle');
                stateCard.classList.add('motion');
            } else {
                stateCard.classList.remove('motion');
                stateCard.classList.add('idle');
            }

            document.getElementById('movementValue').textContent =
                data.movement ? data.movement.toFixed(2) : '-';
        }

        function clearData() {
            chartData.labels = [];
            chartData.movement = [];
            chartData.threshold = [];
            chartData.features = [];
            chartData.packets_processed = [];
            messageCount = 0;
            currentFeatures = null;
            pendingData = [];

            document.getElementById('messageCount').textContent = '0';
            document.getElementById('lastUpdate').textContent = '-';

            chart.update();
        }

        // MQTT Command Functions
        function sendCommand(cmd, params = {}) {
            if (!client || !client.connected) {
                showNotification('Not connected to MQTT broker', 'error');
                return;
            }

            const topic = document.getElementById('topic').value;
            const cmdTopic = topic + '/cmd';
            const message = JSON.stringify({ cmd, ...params });

            client.publish(cmdTopic, message, (err) => {
                if (err) {
                    showNotification(`Failed to send command: ${err.message}`, 'error');
                }
                // Removed "Command sent" notification for cleaner real-time updates
                // Only device responses will show notifications now
            });
        }

        // Apply All Configuration (Detection Parameters + Filters)
        function applyAllConfiguration() {
            // Detection Parameters
            const segThreshold = parseFloat(document.getElementById('segThresholdValue').value);
            const windowSize = parseInt(document.getElementById('windowSizeValue').value);
            const trafficRate = parseInt(document.getElementById('trafficRateValue').value);
            const featuresEnable = document.getElementById('featuresEnable').checked;
            const smartPublishing = document.getElementById('smartPublishing').checked;

            // Filters
            const hampelEnabled = document.getElementById('hampelFilter').checked;
            const hampelThreshold = parseFloat(document.getElementById('hampelThresholdValue').value);
            const savgolEnabled = document.getElementById('savgolFilter').checked;
            const butterworthEnabled = document.getElementById('butterworthFilter').checked;
            const waveletEnabled = document.getElementById('waveletFilter').checked;
            const waveletLevel = parseInt(document.getElementById('waveletLevelValue').value);
            const waveletThreshold = parseFloat(document.getElementById('waveletThresholdValue').value);

            // Send all commands with delays
            let delay = 0;
            sendCommand('segmentation_threshold', { value: segThreshold });
            delay += 100;
            setTimeout(() => sendCommand('segmentation_window_size', { value: windowSize }), delay);
            delay += 100;
            setTimeout(() => sendCommand('traffic_generator_rate', { value: trafficRate }), delay);
            delay += 100;
            setTimeout(() => sendCommand('features_enable', { enabled: featuresEnable }), delay);
            delay += 100;
            setTimeout(() => sendCommand('smart_publishing', { enabled: smartPublishing }), delay);
            delay += 100;
            setTimeout(() => sendCommand('hampel_filter', { enabled: hampelEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('hampel_threshold', { value: hampelThreshold }), delay);
            delay += 100;
            setTimeout(() => sendCommand('savgol_filter', { enabled: savgolEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('butterworth_filter', { enabled: butterworthEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_filter', { enabled: waveletEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_level', { value: waveletLevel }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_threshold', { value: waveletThreshold }), delay);
        }

        // System Info Functions
        function requestInfo() {
            sendCommand('info');
        }

        function requestStats() {
            sendCommand('stats');
        }

        function factoryReset() {
            showFactoryResetModal();
        }

        function showFactoryResetModal() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.onclick = (e) => {
                if (e.target === overlay) closeModal();
            };

            // Create modal content
            const modal = document.createElement('div');
            modal.className = 'modal-content';

            // Modal header
            const header = document.createElement('div');
            header.className = 'modal-header';
            header.innerHTML = `
                <h3 style="color: #e74c3c;">‚ö†Ô∏è Factory Reset</h3>
            `;

            // Modal body
            const body = document.createElement('div');
            body.className = 'modal-body';
            body.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

            let html = '';
            html += `<div style="margin-bottom: 20px;">`;
            html += `<p style="font-size: 1em; color: #e74c3c; font-weight: 600; margin-bottom: 15px;">`;
            html += `This will reset ALL settings to factory defaults!`;
            html += `</p>`;
            html += `<p style="font-size: 0.95em; color: #666; margin-bottom: 10px;">This includes:</p>`;
            html += `<ul style="margin-left: 20px; color: #666; font-size: 0.9em; line-height: 1.8;">`;
            html += `<li>Detection parameters</li>`;
            html += `<li>Filter settings</li>`;
            html += `<li>All saved configurations</li>`;
            html += `</ul>`;
            html += `</div>`;
            html += `<p style="font-size: 0.95em; color: #333; font-weight: 600; margin-top: 20px;">`;
            html += `Are you sure you want to continue?`;
            html += `</p>`;

            body.innerHTML = html;

            // Modal footer with buttons
            const footer = document.createElement('div');
            footer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; padding-top: 20px; border-top: 2px solid #e0e0e0;';
            footer.innerHTML = `
                <button class="btn btn-secondary" onclick="closeModal()" style="padding: 10px 20px;">Cancel</button>
                <button class="btn btn-danger" onclick="confirmFactoryReset()" style="padding: 10px 20px;">Reset to Factory Defaults</button>
            `;

            modal.appendChild(header);
            modal.appendChild(body);
            modal.appendChild(footer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        function confirmFactoryReset() {
            closeModal();
            sendCommand('factory_reset');
            showNotification('Factory reset command sent', 'info');
        }

        // Section Toggle Function
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + 'Content');
            const arrow = document.getElementById(sectionId + 'Arrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        // SubSection Toggle Function
        function toggleSubSection(sectionId) {
            const content = document.getElementById(sectionId + 'Content');
            const arrow = document.getElementById(sectionId + 'Arrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        // Toggle Smart Publishing
        function toggleSmartPublishing() {
            const btn = document.getElementById('smartPublishingBtn');

            // Toggle the state
            smartPublishingEnabled = !smartPublishingEnabled;

            // Update button appearance by switching classes
            if (smartPublishingEnabled) {
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-info');
                btn.textContent = 'Smart Publishing: ON';
            } else {
                btn.classList.remove('btn-info');
                btn.classList.add('btn-secondary');
                btn.textContent = 'Smart Publishing: OFF';
            }

            // Send command to device
            sendCommand('smart_publishing', { enabled: smartPublishingEnabled });
        }

        // Apply Detection Configuration Only
        function applyDetectionConfiguration() {
            const segThreshold = parseFloat(document.getElementById('segThresholdValue').value);
            const windowSize = parseInt(document.getElementById('windowSizeValue').value);
            const trafficRate = parseInt(document.getElementById('trafficRateValue').value);

            // Send detection commands with delays
            let delay = 0;
            sendCommand('segmentation_threshold', { value: segThreshold });
            delay += 100;
            setTimeout(() => sendCommand('segmentation_window_size', { value: windowSize }), delay);
            delay += 100;
            setTimeout(() => sendCommand('traffic_generator_rate', { value: trafficRate }), delay);

            showNotification('Detection configuration applied', 'success');
        }

        // Apply Features & Filters Configuration Only
        function applyFeaturesFiltersConfiguration() {
            const featuresEnable = document.getElementById('featuresEnable').checked;
            const hampelEnabled = document.getElementById('hampelFilter').checked;
            const hampelThreshold = parseFloat(document.getElementById('hampelThresholdValue').value);
            const savgolEnabled = document.getElementById('savgolFilter').checked;
            const butterworthEnabled = document.getElementById('butterworthFilter').checked;
            const waveletEnabled = document.getElementById('waveletFilter').checked;
            const waveletLevel = parseInt(document.getElementById('waveletLevelValue').value);
            const waveletThreshold = parseFloat(document.getElementById('waveletThresholdValue').value);

            // Send features & filters commands with delays
            let delay = 0;
            sendCommand('features_enable', { enabled: featuresEnable });
            delay += 100;
            setTimeout(() => sendCommand('hampel_filter', { enabled: hampelEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('hampel_threshold', { value: hampelThreshold }), delay);
            delay += 100;
            setTimeout(() => sendCommand('savgol_filter', { enabled: savgolEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('butterworth_filter', { enabled: butterworthEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_filter', { enabled: waveletEnabled }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_level', { value: waveletLevel }), delay);
            delay += 100;
            setTimeout(() => sendCommand('wavelet_threshold', { value: waveletThreshold }), delay);

            showNotification('Features & Filters configuration applied', 'success');
        }

        // Notification Function
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Slider Synchronization
        function syncSlider(sliderId, valueId) {
            const slider = document.getElementById(sliderId);
            const valueInput = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                valueInput.value = e.target.value;
            });

            valueInput.addEventListener('input', (e) => {
                slider.value = e.target.value;
            });
        }

        // Enhanced Message Handler for Info/Stats and regular data
        function handleMessage(message) {
            try {
                const data = JSON.parse(message);

                // Log all messages to console for debugging
                console.log('Received message:', data);

                // Check if this is an info response (has network, mqtt, segmentation, filters, options)
                if (data.network || data.mqtt || (data.segmentation && data.filters && data.options)) {
                    console.log('Detected INFO response');
                    populateUIFromConfig(data);
                    return;
                }

                // Check if this is a stats response (has uptime, turbulence, packets_processed)
                if (data.uptime || (data.turbulence !== undefined && data.packets_processed !== undefined)) {
                    console.log('Detected STATS response');
                    displayStats(data);
                    return;
                }

                // Check if this is a simple response message (has "response" field)
                if (data.response && typeof data.response === 'string') {
                    console.log('Detected command response');
                    showNotification(data.response, 'info');
                    // Info is automatically published by device after factory_reset
                    return;
                }

                // Regular data message (has movement, threshold, state)
                if (data.movement !== undefined || data.threshold !== undefined || data.state) {
                    messageCount++;

                    document.getElementById('messageCount').textContent = messageCount;

                    const now = new Date();
                    document.getElementById('lastUpdate').textContent = now.toLocaleTimeString('it-IT', { hour12: false });

                    currentFeatures = data.features || null;

                    updateMetrics(data);

                    if (isPaused) {
                        pendingData.push(data);
                    } else {
                        addDataToChart(data);
                    }
                }

            } catch (err) {
                console.error('Error parsing message:', err);
            }
        }

        // Format uptime to human readable format
        function formatUptime(uptime) {
            if (!uptime) return 'N/A';

            // If uptime is already a formatted string, return it as is
            if (typeof uptime === 'string') {
                return uptime;
            }

            // If uptime is a number (seconds), format it
            if (typeof uptime === 'number') {
                const hours = Math.floor(uptime / 3600);
                const minutes = Math.floor((uptime % 3600) / 60);
                const secs = uptime % 60;
                return `${hours}h ${minutes}m ${secs}s`;
            }

            return 'N/A';
        }

        // Format large numbers with thousands separator
        function formatNumber(num) {
            if (num === undefined || num === null) return 'N/A';
            return num.toLocaleString();
        }

        // Refresh stats in modal
        function refreshStats() {
            const reloadBtn = document.getElementById('statsReloadBtn');
            if (reloadBtn) {
                reloadBtn.classList.add('spinning');
                reloadBtn.disabled = true;
            }

            // Send stats command
            sendCommand('stats');

            // Re-enable button after a delay
            setTimeout(() => {
                if (reloadBtn) {
                    reloadBtn.classList.remove('spinning');
                    reloadBtn.disabled = false;
                }
            }, 1000);
        }

        // Display Stats in modal
        function displayStats(stats) {
            // Check if modal already exists
            let overlay = document.querySelector('.modal-overlay');
            let isUpdate = false;

            if (overlay) {
                // Modal exists, just update the content
                isUpdate = true;
            } else {
                // Create new modal overlay
                overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.onclick = (e) => {
                    if (e.target === overlay) closeModal();
                };
            }

            // Create or get modal content
            let modal = overlay.querySelector('.modal-content');
            if (!modal) {
                modal = document.createElement('div');
                modal.className = 'modal-content';
            } else {
                modal.innerHTML = ''; // Clear existing content
            }

            // Modal header with reload button
            const header = document.createElement('div');
            header.className = 'modal-header';
            header.innerHTML = `
                <h3>Statistics</h3>
                <div class="modal-header-actions">
                    <button class="modal-reload" id="statsReloadBtn" onclick="refreshStats()" title="Refresh statistics">üîÑ</button>
                </div>
            `;

            // Modal body with organized sections
            const body = document.createElement('div');
            body.className = 'modal-body';

            // Determine state color
            const stateClass = stats.state === 'motion' ? 'warning' : 'success';
            const stateIcon = stats.state === 'motion' ? 'üî¥' : 'üü¢';

            let html = '';

            // System Status Section
            html += `<div class="stat-section">`;
            html += `<div class="stat-section-title">üìä System Status</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">${stateIcon} State</span>`;
            html += `<span class="stat-value ${stateClass}">${(stats.state || 'N/A').toUpperCase()}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">‚è±Ô∏è Uptime</span>`;
            html += `<span class="stat-value">${formatUptime(stats.uptime)}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üíª CPU Usage</span>`;
            html += `<span class="stat-value highlight">${stats.cpu_usage_percent !== undefined ? stats.cpu_usage_percent.toFixed(1) + '%' : 'N/A'}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üß† RAM Usage</span>`;
            html += `<span class="stat-value highlight">${stats.heap_usage_percent !== undefined ? stats.heap_usage_percent.toFixed(1) + '%' : 'N/A'}</span>`;
            html += `</div>`;
            html += `</div>`;

            // Detection Metrics Section
            html += `<div class="stat-section">`;
            html += `<div class="stat-section-title">üéØ Detection Metrics</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üåä Turbulence</span>`;
            html += `<span class="stat-value highlight">${stats.turbulence?.toFixed(3) || 'N/A'}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üìà Movement</span>`;
            html += `<span class="stat-value highlight">${stats.movement?.toFixed(3) || 'N/A'}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üéöÔ∏è Threshold</span>`;
            html += `<span class="stat-value">${stats.threshold?.toFixed(3) || 'N/A'}</span>`;
            html += `</div>`;
            html += `</div>`;

            // Counters Section
            html += `<div class="stat-section">`;
            html += `<div class="stat-section-title">üìà Counters</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">üì¶ Packets Processed</span>`;
            html += `<span class="stat-value highlight">${formatNumber(stats.packets_processed)}</span>`;
            html += `</div>`;
            html += `<div class="stat-line">`;
            html += `<span class="stat-label">‚ùå Packets Dropped</span>`;
            html += `<span class="stat-value ${stats.packets_dropped > 0 ? 'warning' : 'success'}">${formatNumber(stats.packets_dropped)}</span>`;
            html += `</div>`;
            html += `</div>`;

            body.innerHTML = html;

            modal.appendChild(header);
            modal.appendChild(body);

            if (!isUpdate) {
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
            }
        }

        // Close modal
        function closeModal() {
            const overlay = document.querySelector('.modal-overlay');
            if (overlay) {
                overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
                setTimeout(() => overlay.remove(), 300);
            }
        }

        // Update subcarrier selection
        function updateSubcarriers() {
            const indicesStr = document.getElementById('subcarrierIndices').value.trim();

            if (!indicesStr) {
                showNotification('Please enter subcarrier indices', 'error');
                return;
            }

            // Parse comma-separated values
            const indices = indicesStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));

            if (indices.length === 0) {
                showNotification('Invalid format. Use comma-separated numbers (e.g., 47,48,49,50)', 'error');
                return;
            }

            // Validate range (0-63)
            const invalidIndices = indices.filter(n => n < 0 || n > 63);
            if (invalidIndices.length > 0) {
                showNotification(`Invalid indices: ${invalidIndices.join(',')} (must be 0-63)`, 'error');
                return;
            }

            // Validate count (1-64)
            if (indices.length > 64) {
                showNotification('Too many subcarriers (max 64)', 'error');
                return;
            }

            // Send command
            sendCommand('subcarrier_selection', { indices: indices });
            showNotification(`Updating ${indices.length} subcarriers...`, 'info');
        }

        // Populate UI controls from config data
        function populateUIFromConfig(config) {
            console.log('Populating UI from config:', config);

            // Show/hide Feature Parameters Section based on features_enabled presence
            const featureSection = document.getElementById('featureParametersSection');
            if (config.options && config.options.features_enabled !== undefined) {
                // Features are supported - show the section
                featureSection.style.display = 'block';
            } else {
                // Features not supported (e.g., Micro-ESPectre) - hide the section
                featureSection.style.display = 'none';
            }

            // Update Device & Network Information
            if (config.device && config.device.type) {
                document.getElementById('deviceType').textContent = config.device.type;
            }
            
            if (config.network) {
                if (config.network.ip_address) {
                    document.getElementById('deviceIP').textContent = config.network.ip_address;
                }
                if (config.network.mac_address) {
                    document.getElementById('deviceMAC').textContent = config.network.mac_address;
                }
                if (config.network.channel) {
                    const primary = config.network.channel.primary || '-';
                    const secondary = config.network.channel.secondary || 0;
                    const channelText = secondary > 0 ? `${primary} + ${secondary}` : `${primary}`;
                    document.getElementById('wifiChannel').textContent = channelText;
                }
                if (config.network.bandwidth) {
                    document.getElementById('wifiBandwidth').textContent = config.network.bandwidth;
                }
                if (config.network.protocol) {
                    document.getElementById('wifiProtocol').textContent = config.network.protocol;
                }
                if (config.network.promiscuous_mode !== undefined) {
                    document.getElementById('wifiPromiscuous').textContent = config.network.promiscuous_mode ? 'Yes' : 'No';
                }
            }

            // Subcarrier selection
            if (config.subcarriers) {
                if (config.subcarriers.indices && Array.isArray(config.subcarriers.indices)) {
                    const indicesStr = config.subcarriers.indices.join(',');
                    document.getElementById('subcarrierIndices').value = indicesStr;
                }
            }

            // Detection Parameters
            if (config.segmentation) {
                if (config.segmentation.threshold !== undefined) {
                    const threshold = config.segmentation.threshold;
                    document.getElementById('segThreshold').value = threshold;
                    document.getElementById('segThresholdValue').value = threshold;
                }
                if (config.segmentation.window_size !== undefined) {
                    const windowSize = config.segmentation.window_size;
                    document.getElementById('windowSize').value = windowSize;
                    document.getElementById('windowSizeValue').value = windowSize;
                }
            }

            if (config.network && config.network.traffic_generator_rate !== undefined) {
                const rate = config.network.traffic_generator_rate;
                document.getElementById('trafficRate').value = rate;
                document.getElementById('trafficRateValue').value = rate;
            }

            if (config.options) {
                if (config.options.features_enabled !== undefined) {
                    document.getElementById('featuresEnable').checked = config.options.features_enabled;
                }
                if (config.options.smart_publishing_enabled !== undefined) {
                    smartPublishingEnabled = config.options.smart_publishing_enabled;

                    // Update button appearance by switching classes
                    const btn = document.getElementById('smartPublishingBtn');
                    if (smartPublishingEnabled) {
                        btn.classList.remove('btn-secondary');
                        btn.classList.add('btn-info');
                        btn.textContent = 'Smart Publishing: ON';
                    } else {
                        btn.classList.remove('btn-info');
                        btn.classList.add('btn-secondary');
                        btn.textContent = 'Smart Publishing: OFF';
                    }
                }
            }

            // Filters
            if (config.filters) {
                if (config.filters.hampel_enabled !== undefined) {
                    document.getElementById('hampelFilter').checked = config.filters.hampel_enabled;
                }
                if (config.filters.hampel_threshold !== undefined) {
                    const threshold = config.filters.hampel_threshold;
                    document.getElementById('hampelThreshold').value = threshold;
                    document.getElementById('hampelThresholdValue').value = threshold;
                }

                if (config.filters.savgol_enabled !== undefined) {
                    document.getElementById('savgolFilter').checked = config.filters.savgol_enabled;
                }

                if (config.filters.butterworth_enabled !== undefined) {
                    document.getElementById('butterworthFilter').checked = config.filters.butterworth_enabled;
                }

                if (config.filters.wavelet_enabled !== undefined) {
                    document.getElementById('waveletFilter').checked = config.filters.wavelet_enabled;
                }
                if (config.filters.wavelet_level !== undefined) {
                    const level = config.filters.wavelet_level;
                    document.getElementById('waveletLevel').value = level;
                    document.getElementById('waveletLevelValue').value = level;
                }
                if (config.filters.wavelet_threshold !== undefined) {
                    const threshold = config.filters.wavelet_threshold;
                    document.getElementById('waveletThreshold').value = threshold;
                    document.getElementById('waveletThresholdValue').value = threshold;
                }
            }

            showNotification('Configuration loaded from device', 'success');
        }

        // Debounce helper function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Real-time configuration update functions with debounce
        const debouncedSendCommand = debounce((cmd, params) => {
            sendCommand(cmd, params);
        }, 300);

        // Setup real-time listeners for Detection Parameters
        function setupDetectionListeners() {
            // Segmentation Threshold
            document.getElementById('segThreshold').addEventListener('change', (e) => {
                debouncedSendCommand('segmentation_threshold', { value: parseFloat(e.target.value) });
            });
            document.getElementById('segThresholdValue').addEventListener('change', (e) => {
                debouncedSendCommand('segmentation_threshold', { value: parseFloat(e.target.value) });
            });

            // Window Size
            document.getElementById('windowSize').addEventListener('change', (e) => {
                debouncedSendCommand('segmentation_window_size', { value: parseInt(e.target.value) });
            });
            document.getElementById('windowSizeValue').addEventListener('change', (e) => {
                debouncedSendCommand('segmentation_window_size', { value: parseInt(e.target.value) });
            });

            // Traffic Rate
            document.getElementById('trafficRate').addEventListener('change', (e) => {
                debouncedSendCommand('traffic_generator_rate', { value: parseInt(e.target.value) });
            });
            document.getElementById('trafficRateValue').addEventListener('change', (e) => {
                debouncedSendCommand('traffic_generator_rate', { value: parseInt(e.target.value) });
            });
        }

        // Setup real-time listener for Subcarrier Selection
        function setupSubcarrierListener() {
            const subcarrierInput = document.getElementById('subcarrierIndices');
            
            // Debounced update function with longer delay for text input
            const debouncedUpdateSubcarriers = debounce(() => {
                updateSubcarriers();
            }, 500);
            
            // Listen for input changes
            subcarrierInput.addEventListener('input', () => {
                debouncedUpdateSubcarriers();
            });
        }

        // Setup real-time listeners for Features & Filters
        function setupFeaturesFiltersListeners() {
            // Features Enable
            document.getElementById('featuresEnable').addEventListener('change', (e) => {
                sendCommand('features_enable', { enabled: e.target.checked });
            });

            // Hampel Filter
            document.getElementById('hampelFilter').addEventListener('change', (e) => {
                sendCommand('hampel_filter', { enabled: e.target.checked });
            });
            document.getElementById('hampelThreshold').addEventListener('change', (e) => {
                debouncedSendCommand('hampel_threshold', { value: parseFloat(e.target.value) });
            });
            document.getElementById('hampelThresholdValue').addEventListener('change', (e) => {
                debouncedSendCommand('hampel_threshold', { value: parseFloat(e.target.value) });
            });

            // Savitzky-Golay Filter
            document.getElementById('savgolFilter').addEventListener('change', (e) => {
                sendCommand('savgol_filter', { enabled: e.target.checked });
            });

            // Butterworth Filter
            document.getElementById('butterworthFilter').addEventListener('change', (e) => {
                sendCommand('butterworth_filter', { enabled: e.target.checked });
            });

            // Wavelet Filter
            document.getElementById('waveletFilter').addEventListener('change', (e) => {
                sendCommand('wavelet_filter', { enabled: e.target.checked });
            });
            document.getElementById('waveletLevel').addEventListener('change', (e) => {
                debouncedSendCommand('wavelet_level', { value: parseInt(e.target.value) });
            });
            document.getElementById('waveletLevelValue').addEventListener('change', (e) => {
                debouncedSendCommand('wavelet_level', { value: parseInt(e.target.value) });
            });
            document.getElementById('waveletThreshold').addEventListener('change', (e) => {
                debouncedSendCommand('wavelet_threshold', { value: parseFloat(e.target.value) });
            });
            document.getElementById('waveletThresholdValue').addEventListener('change', (e) => {
                debouncedSendCommand('wavelet_threshold', { value: parseFloat(e.target.value) });
            });
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initChart();

            // Sync all sliders with their value inputs
            syncSlider('segThreshold', 'segThresholdValue');
            syncSlider('windowSize', 'windowSizeValue');
            syncSlider('trafficRate', 'trafficRateValue');
            syncSlider('hampelThreshold', 'hampelThresholdValue');
            syncSlider('waveletLevel', 'waveletLevelValue');
            syncSlider('waveletThreshold', 'waveletThresholdValue');

            // Setup real-time configuration listeners
            setupDetectionListeners();
            setupSubcarrierListener();
            setupFeaturesFiltersListeners();
        });
    </script>
</body>

</html>
