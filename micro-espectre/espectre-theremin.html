<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPectre Wi-Fi Theremin</title>

    <!-- MQTT.js -->
    <script src="https://unpkg.com/mqtt@5.3.0/dist/mqtt.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .card.compact {
            padding: 12px 20px;
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapsible-header h2 {
            margin: 0;
            font-size: 1.2em;
        }

        .collapsible-content {
            margin-top: 15px;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
            font-size: 0.9em;
        }

        .input-group input,
        .input-group select {
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #2ecc71;
        }

        .status-indicator.disconnected {
            background: #e74c3c;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .metric-card {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .metric-card:hover {
            transform: translateY(-3px);
        }

        .metric-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .slider-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .slider-group input[type="range"] {
            flex: 1;
        }

        .slider-group input[type="number"] {
            width: 80px;
            padding: 6px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            gap: 10px;
        }

        .toggle-label input[type="checkbox"] {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            transition: background 0.3s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
        }

        .toggle-label input[type="checkbox"]:checked+.toggle-slider {
            background: #667eea;
        }

        .toggle-label input[type="checkbox"]:checked+.toggle-slider::before {
            transform: translateX(24px);
        }

        .toggle-text {
            font-weight: 600;
            color: #333;
        }

        .arrow {
            transition: transform 0.3s;
            font-size: 0.9em;
        }

        .arrow.rotate {
            transform: rotate(180deg);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .notification.success {
            background: #2ecc71;
        }

        .notification.error {
            background: #e74c3c;
        }

        .notification.info {
            background: #3498db;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üõú ESPectre üëª</h1>
            <p>Sonification of WiFi CSI Movement Data (WiFi Theremin)</p>
        </div>

        <!-- MQTT Configuration Card -->
        <div class="card compact">
            <div class="collapsible-header" onclick="toggleConfig()" style="display: flex; align-items: center; gap: 15px;">
                <h2 style="margin: 0;">‚öôÔ∏è MQTT Configuration</h2>
                <div class="status-item" style="margin-left: auto;">
                    <div class="status-indicator disconnected" id="statusIndicator"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <span class="arrow" id="configArrow">‚ñº</span>
            </div>
            <div class="collapsible-content" id="configContent">
                <div class="config-section">
                    <div class="input-group">
                        <label for="broker">Broker Address</label>
                        <input type="text" id="broker" placeholder="homeassistant.local" value="homeassistant.local">
                    </div>
                    <div class="input-group">
                        <label for="port">WebSocket Port</label>
                        <input type="number" id="port" placeholder="9001" value="9001">
                    </div>
                    <div class="input-group">
                        <label for="topic">Topic</label>
                        <input type="text" id="topic" placeholder="home/espectre/node1" value="home/espectre/node1">
                    </div>
                    <div class="input-group">
                        <label for="username">Username (optional)</label>
                        <input type="text" id="username" placeholder="user" value="mqtt">
                    </div>
                    <div class="input-group">
                        <label for="password">Password (optional)</label>
                        <input type="password" id="password" placeholder="password" value="mqtt">
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">Connect</button>
                    <button class="btn btn-danger" id="clearBtn" onclick="clearData()" style="display: none;">Clear Data</button>
                </div>
            </div>
        </div>

        <!-- Status Metrics -->
        <div class="card compact">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Movement</div>
                    <div class="metric-value" id="movementValue">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Frequency</div>
                    <div class="metric-value" id="frequencyValue">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Current Note</div>
                    <div class="metric-value" id="currentNote">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label" id="featureLabel">Octave</div>
                    <div class="metric-value" id="octaveOrFeature">-</div>
                </div>
            </div>
        </div>

        <!-- Theremin Controls -->
        <div class="card">
            <div class="collapsible-header" onclick="toggleSection('theremin')">
                <h2>üéπ Theremin Controls</h2>
                <span class="arrow rotate" id="thereminArrow">‚ñº</span>
            </div>
            <div class="collapsible-content" id="thereminContent">

                <!-- Audio -->
                <div style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                    <div class="collapsible-header" onclick="toggleSubSection('audio')" style="padding: 5px 0;">
                        <h3 style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üîä</span> Audio
                        </h3>
                        <span class="arrow" id="audioArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content" id="audioContent" style="margin-top: 15px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label for="volume">Volume</label>
                                <div class="slider-group">
                                    <input type="range" id="volume" min="0" max="100" step="5" value="50">
                                    <input type="number" id="volumeValue" min="0" max="100" step="5" value="50">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Audio output volume (0-100%)</small>
                            </div>
                            <div class="input-group">
                                <label for="smoothing">Smoothing Factor (%)</label>
                                <div class="slider-group">
                                    <input type="range" id="smoothing" min="0" max="100" step="5" value="30">
                                    <input type="number" id="smoothingValue" min="0" max="100" step="5" value="30">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Smoothing factor for smoother transitions (0=none, 100=maximum)</small>
                            </div>
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="logarithmicMapping" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Logarithmic Mapping (Musical)</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Logarithmic mapping for natural musical scale (octaves)</small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Frequency -->
                <div style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                    <div class="collapsible-header" onclick="toggleSubSection('frequency')" style="padding: 5px 0;">
                        <h3 style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üìä</span> Frequency
                        </h3>
                        <span class="arrow" id="frequencyArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content collapsed" id="frequencyContent" style="margin-top: 15px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label for="baseFreq">Base Frequency (Hz)</label>
                                <div class="slider-group">
                                    <input type="range" id="baseFreq" min="100" max="500" step="10" value="100">
                                    <input type="number" id="baseFreqValue" min="100" max="500" step="10" value="100">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Minimum theremin frequency (starting frequency)</small>
                            </div>
                            <div class="input-group">
                                <label for="freqRange">Frequency Range (Hz)</label>
                                <div class="slider-group">
                                    <input type="range" id="freqRange" min="400" max="4000" step="100" value="4000">
                                    <input type="number" id="freqRangeValue" min="400" max="4000" step="100" value="4000">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Amplitude of available frequency range</small>
                            </div>
                            <div class="input-group">
                                <label for="maxMovement">Max Movement Value</label>
                                <div class="slider-group">
                                    <input type="range" id="maxMovement" min="0.5" max="20" step="0.1" value="10.0">
                                    <input type="number" id="maxMovementValue" min="0.5" max="20" step="0.1" value="10.0">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Movement value that maps to highest frequency</small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Mode and Musical Scale -->
                <div style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                    <div class="collapsible-header" onclick="toggleSubSection('modeScale')" style="padding: 5px 0;">
                        <h3 style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üéµ</span> Mode and Musical Scale
                        </h3>
                        <span class="arrow" id="modeScaleArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content collapsed" id="modeScaleContent" style="margin-top: 15px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            <div class="input-group">
                                <label for="thereminMode">Operating Mode</label>
                                <select id="thereminMode">
                                    <option value="continuous">Continuous (Glissando)</option>
                                    <option value="quantized">Quantized (Musical Scale)</option>
                                    <option value="hybrid" selected>Hybrid</option>
                                </select>
                                <small style="color: #666; font-size: 0.8em;">Continuous: continuous frequencies | Quantized: discrete notes | Hybrid: combination</small>
                            </div>
                            <div class="input-group">
                                <label for="thereminScale">Musical Scale</label>
                                <select id="thereminScale">
                                    <option value="pentatonic">Pentatonic</option>
                                    <option value="major">Major</option>
                                    <option value="minor">Minor</option>
                                    <option value="chromatic" selected>Chromatic</option>
                                </select>
                                <small style="color: #666; font-size: 0.8em;">Musical scale for frequency quantization</small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Feature Modulation -->
                <div id="featureModulationSection" style="background: #f8f9fa; border-radius: 10px; padding: 15px; margin-bottom: 15px; border: 2px solid #e0e0e0; display: none;">
                    <div class="collapsible-header" onclick="toggleSubSection('featureMod')" style="padding: 5px 0;">
                        <h3 style="margin: 0; color: #667eea; font-size: 1.1em; display: flex; align-items: center; gap: 8px;">
                            <span>üéõÔ∏è</span> Feature Modulation
                        </h3>
                        <span class="arrow" id="featureModArrow">‚ñº</span>
                    </div>
                    <div class="collapsible-content collapsed" id="featureModContent" style="margin-top: 15px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            <!-- Waveform Modulation -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="waveformModEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Waveform Modulation (Entropy)</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Modulate waveform type (sine/square/sawtooth) based on entropy</small>
                            </div>
                            
                            <!-- Vibrato Modulation -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="vibratoModEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Vibrato Modulation</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Pitch modulation using temporal and spatial features</small>
                            </div>
                            <div class="input-group">
                                <label for="vibratoSpeed">Vibrato Speed (temporal_delta_mean)</label>
                                <div class="slider-group">
                                    <input type="range" id="vibratoSpeed" min="0.1" max="20" step="0.1" value="5.0">
                                    <input type="number" id="vibratoSpeedValue" min="0.1" max="20" step="0.1" value="5.0">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Speed multiplier for vibrato</small>
                            </div>
                            <div class="input-group">
                                <label for="vibratoDepth">Vibrato Depth (spatial_variance)</label>
                                <div class="slider-group">
                                    <input type="range" id="vibratoDepth" min="0" max="100" step="5" value="20">
                                    <input type="number" id="vibratoDepthValue" min="0" max="100" step="5" value="20">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Depth multiplier (cents)</small>
                            </div>
                            
                            <!-- Filter Modulation -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="filterModEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Filter Modulation</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Dynamic low-pass filter using kurtosis and skewness</small>
                            </div>
                            <div class="input-group">
                                <label for="filterCutoff">Filter Cutoff Base (Hz)</label>
                                <div class="slider-group">
                                    <input type="range" id="filterCutoff" min="200" max="8000" step="100" value="4000">
                                    <input type="number" id="filterCutoffValue" min="200" max="8000" step="100" value="4000">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Base cutoff frequency (kurtosis modulates this)</small>
                            </div>
                            <div class="input-group">
                                <label for="filterResonance">Filter Resonance (skewness)</label>
                                <div class="slider-group">
                                    <input type="range" id="filterResonance" min="0" max="20" step="1" value="5">
                                    <input type="number" id="filterResonanceValue" min="0" max="20" step="1" value="5">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Resonance multiplier</small>
                            </div>
                            
                            <!-- Stereo Pan Modulation -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="stereoPanEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Stereo Pan (spatial_correlation)</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Panoramic positioning based on spatial correlation</small>
                            </div>
                            
                            <!-- Scale Selection -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="autoScaleEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Auto Scale Selection</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Automatically select scale based on entropy and variance</small>
                            </div>
                            
                            <!-- Tremolo -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="tremoloEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Tremolo (Feature-based)</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Volume modulation using temporal_delta_variance and spatial_gradient</small>
                            </div>
                            <div class="input-group">
                                <label for="tremoloSpeed">Tremolo Speed (temporal_delta_variance)</label>
                                <div class="slider-group">
                                    <input type="range" id="tremoloSpeed" min="0.1" max="20" step="0.1" value="5.0">
                                    <input type="number" id="tremoloSpeedValue" min="0.1" max="20" step="0.1" value="5.0">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Speed multiplier for tremolo</small>
                            </div>
                            <div class="input-group">
                                <label for="tremoloDepth">Tremolo Depth (spatial_gradient)</label>
                                <div class="slider-group">
                                    <input type="range" id="tremoloDepth" min="0" max="100" step="5" value="50">
                                    <input type="number" id="tremoloDepthValue" min="0" max="100" step="5" value="50">
                                </div>
                                <small style="color: #666; font-size: 0.8em;">Depth multiplier (%)</small>
                            </div>
                            
                            <!-- Effects Modulation -->
                            <div class="input-group">
                                <label class="toggle-label">
                                    <input type="checkbox" id="effectsModEnable" checked>
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-text">Effects Modulation</span>
                                </label>
                                <small style="color: #666; font-size: 0.8em; margin-top: 5px; display: block;">Reverb/delay using IQR, distortion using kurtosis</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // MQTT Client
        let client = null;
        let messageCount = 0;
        
        // Current features from MQTT
        let currentFeatures = null;

        // Web Audio API
        let audioContext = null;
        let oscillator = null;
        let gainNode = null;
        let isAudioInitialized = false;

        // Theremin State
        let thereminConfig = {
            enabled: true, // Always enabled
            mode: 'quantized', // continuous, quantized, hybrid
            scale: 'pentatonic', // pentatonic, major, minor, chromatic
            baseFrequency: 200,
            frequencyRange: 1800,
            smoothingFactor: 0.3, // 0-1
            volume: 0.5, // 0-1
            logarithmicMapping: true,
            hybridThreshold: 0.5,
            maxMovement: 4.0 // Maximum movement value that maps to highest frequency
        };

        // Tremolo State
        let tremoloState = {
            packetsProcessed: 0,
            lastPacketsProcessed: 0,
            tremoloPhase: 0,
            tremoloTime: 0
        };

        // Feature Modulation Configuration
        let featureModConfig = {
            waveformEnabled: false,
            vibratoEnabled: false,
            vibratoSpeedMult: 5.0,
            vibratoDepthMult: 20, // cents
            filterEnabled: false,
            filterCutoffBase: 4000, // Hz
            filterResonanceMult: 5,
            stereoPanEnabled: false,
            autoScaleEnabled: false,
            tremoloEnabled: false,
            tremoloSpeed: 5.0, // multiplier
            tremoloDepth: 0.5, // 0-1 (50%)
            effectsEnabled: false
        };
        
        // Vibrato state
        let vibratoState = {
            phase: 0,
            time: 0
        };

        // Interpolation State
        let lastMovement = 0;
        let targetMovement = 0;
        let smoothedMovement = 0;
        let lastUpdateTime = 0;
        let interpolationActive = false;
        const INTERPOLATION_RATE = 60; // Hz (60 updates per second)
        const MQTT_RATE = 1; // Hz (1 message per second)

        // Musical Scales
        const PENTATONIC_RATIOS = [1.0, 9/8, 5/4, 3/2, 5/3, 2.0];
        const MAJOR_RATIOS = [1.0, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2.0];
        const MINOR_RATIOS = [1.0, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5, 2.0];
        const CHROMATIC_RATIOS = [];
        
        // Initialize chromatic scale
        for (let i = 0; i <= 12; i++) {
            CHROMATIC_RATIOS.push(Math.pow(2, i / 12));
        }

        // Get scale ratios
        function getScaleRatios(scale) {
            switch (scale) {
                case 'pentatonic':
                    return PENTATONIC_RATIOS;
                case 'major':
                    return MAJOR_RATIOS;
                case 'minor':
                    return MINOR_RATIOS;
                case 'chromatic':
                    return CHROMATIC_RATIOS;
                default:
                    return PENTATONIC_RATIOS;
            }
        }

        // Convert frequency to MIDI note number
        function frequencyToMIDI(freq) {
            // A4 = 440 Hz = MIDI note 69
            if (freq <= 0) return null;
            const midiNote = 12 * Math.log2(freq / 440) + 69;
            return midiNote;
        }

        // Convert MIDI note to note name
        function midiToNoteName(midiNote) {
            if (midiNote === null || midiNote < 0 || midiNote > 127) return '-';
            
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const note = noteNames[Math.round(midiNote) % 12];
            const octave = Math.floor(Math.round(midiNote) / 12) - 1;
            return note + octave;
        }

        // Get octave from MIDI note
        function midiToOctave(midiNote) {
            if (midiNote === null || midiNote < 0 || midiNote > 127) return '-';
            return Math.floor(Math.round(midiNote) / 12) - 1;
        }

        // Map movement to frequency (logarithmic or linear)
        function mapMovementToFrequency(movement) {
            // Normalize movement (0-1) using configurable max movement value
            const normalized = Math.min(Math.max(movement / thereminConfig.maxMovement, 0), 1);
            
            const baseFreq = thereminConfig.baseFrequency;
            const freqRange = thereminConfig.frequencyRange;
            const maxFreq = baseFreq + freqRange;
            
            let freq;
            if (thereminConfig.logarithmicMapping) {
                // Logarithmic mapping (musical scale)
                const octaves = Math.log2(maxFreq / baseFreq);
                const targetOctaves = normalized * octaves;
                freq = baseFreq * Math.pow(2, targetOctaves);
            } else {
                // Linear mapping
                freq = baseFreq + (normalized * freqRange);
            }
            
            return Math.max(20, Math.min(20000, freq)); // Clamp to audible range
        }

        // Quantize frequency to nearest note in scale
        function quantizeToScale(freq) {
            const ratios = getScaleRatios(thereminConfig.scale);
            const baseFreq = thereminConfig.baseFrequency;
            
            // Find which octave we're in
            const octave = Math.floor(Math.log2(freq / baseFreq));
            const baseInOctave = baseFreq * Math.pow(2, octave);
            
            // Calculate ratio within octave
            const ratio = freq / baseInOctave;
            
            // Find closest note in scale
            let closestIdx = 0;
            let minDiff = Math.abs(ratio - ratios[0]);
            
            for (let i = 1; i < ratios.length; i++) {
                const diff = Math.abs(ratio - ratios[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }
            
            // Return quantized frequency
            return baseInOctave * ratios[closestIdx];
        }

        // Apply theremin mode processing
        function processFrequency(targetFreq, movementDelta) {
            // Get scale (auto or manual)
            const scale = getAutoScale();
            const originalScale = thereminConfig.scale;
            
            // Temporarily override scale if auto-scale is enabled
            if (featureModConfig.autoScaleEnabled && scale !== originalScale) {
                thereminConfig.scale = scale;
            }
            
            let result;
            switch (thereminConfig.mode) {
                case 'continuous':
                    result = targetFreq;
                    break;
                    
                case 'quantized':
                    result = quantizeToScale(targetFreq);
                    break;
                    
                case 'hybrid':
                    if (Math.abs(movementDelta) < thereminConfig.hybridThreshold) {
                        result = quantizeToScale(targetFreq);
                    } else {
                        result = targetFreq;
                    }
                    break;
                    
                default:
                    result = targetFreq;
            }
            
            // Restore original scale
            if (featureModConfig.autoScaleEnabled && scale !== originalScale) {
                thereminConfig.scale = originalScale;
            }
            
            return result;
        }

        // Initialize Web Audio API
        function initAudio() {
            if (isAudioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                oscillator = audioContext.createOscillator();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = thereminConfig.baseFrequency;
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                gainNode.gain.value = 0; // Start muted
                oscillator.start();
                
                isAudioInitialized = true;
                console.log('Audio initialized');
            } catch (err) {
                console.error('Failed to initialize audio:', err);
                showNotification('Audio initialization failed. Click to enable.', 'error');
            }
        }

        // Resume audio context (required for autoplay policy)
        async function resumeAudio() {
            if (!audioContext) {
                initAudio();
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            if (gainNode && gainNode.gain.value === 0) {
                gainNode.gain.value = thereminConfig.volume;
            }
        }

        // Update octave display
        function updateOctaveOrFeature(octave) {
            const featureLabel = document.getElementById('featureLabel');
            const octaveOrFeature = document.getElementById('octaveOrFeature');
            
            // Always show octave
            featureLabel.textContent = 'Octave';
            octaveOrFeature.textContent = octave;
        }

        // Update oscillator frequency
        function updateFrequency(freq) {
            if (!oscillator || !isAudioInitialized) return;
            
            // Clamp frequency to valid range
            freq = Math.max(20, Math.min(20000, freq));
            
            // Apply vibrato if enabled
            const vibratoRatio = calculateVibrato();
            if (vibratoRatio !== 1.0) {
                freq = freq * vibratoRatio;
            }
            
            // Update waveform type
            const waveformType = getWaveformType();
            if (oscillator.type !== waveformType) {
                oscillator.type = waveformType;
            }
            
            // Use exponential ramp for smooth transitions
            const currentFreq = oscillator.frequency.value;
            const now = audioContext.currentTime;
            
            oscillator.frequency.setTargetAtTime(freq, now, 0.01);
            
            // Update filter
            updateFilter(freq);
            
            // Update stereo pan
            updateStereoPan();
            
            // Calculate and display musical note
            const midiNote = frequencyToMIDI(freq);
            const noteName = midiToNoteName(midiNote);
            const octave = midiToOctave(midiNote);
            
            // Update UI
            document.getElementById('frequencyValue').textContent = freq.toFixed(1) + ' Hz';
            document.getElementById('currentNote').textContent = noteName;
            updateOctaveOrFeature(octave);
        }


        // Get waveform type based on entropy
        function getWaveformType() {
            if (!featureModConfig.waveformEnabled || !currentFeatures || currentFeatures.entropy === undefined) {
                return 'sine';
            }
            
            // Normalize entropy (typical range: 0-8)
            const normalized = Math.min(currentFeatures.entropy / 8.0, 1.0);
            
            if (normalized < 0.33) {
                return 'sine';
            } else if (normalized < 0.66) {
                return 'square';
            } else {
                return 'sawtooth';
            }
        }
        
        // Calculate vibrato modulation
        function calculateVibrato() {
            if (!featureModConfig.vibratoEnabled || !currentFeatures) {
                return 1.0; // No modulation
            }
            
            const temporalDelta = currentFeatures.temporal_delta_mean || 0;
            const spatialVar = currentFeatures.spatial_variance || 0;
            
            // Speed based on temporal_delta_mean (normalize to 0-10 Hz range)
            const speed = Math.min(temporalDelta * featureModConfig.vibratoSpeedMult, 20);
            
            // Depth based on spatial_variance (normalize to 0-1, then to cents)
            const depthNormalized = Math.min(spatialVar / 10.0, 1.0);
            const depthCents = depthNormalized * featureModConfig.vibratoDepthMult;
            
            // Update vibrato phase
            vibratoState.time += 1.0 / INTERPOLATION_RATE;
            vibratoState.phase = (vibratoState.phase + (speed / INTERPOLATION_RATE)) % (2 * Math.PI);
            
            // Calculate vibrato in cents (convert to frequency ratio)
            const vibratoCents = Math.sin(vibratoState.phase) * depthCents;
            const frequencyRatio = Math.pow(2, vibratoCents / 1200);
            
            return frequencyRatio;
        }
        
        // Update filter if enabled
        function updateFilter(freq) {
            if (!gainNode || !isAudioInitialized) {
                return;
            }
            
            // If filter is disabled but exists, remove it
            if (!featureModConfig.filterEnabled && window.biquadFilter) {
                oscillator.disconnect();
                if (window.stereoPanner) {
                    oscillator.connect(window.stereoPanner);
                } else {
                    oscillator.connect(gainNode);
                }
                window.biquadFilter = null;
                return;
            }
            
            if (!featureModConfig.filterEnabled) {
                return;
            }
            
            // Create filter if it doesn't exist
            if (!window.biquadFilter) {
                window.biquadFilter = audioContext.createBiquadFilter();
                window.biquadFilter.type = 'lowpass';
                // Reconnect: oscillator -> filter -> gain -> destination
                oscillator.disconnect();
                oscillator.connect(window.biquadFilter);
                window.biquadFilter.connect(gainNode);
            }
            
            if (!currentFeatures) {
                window.biquadFilter.frequency.value = featureModConfig.filterCutoffBase;
                window.biquadFilter.Q.value = 1;
                return;
            }
            
            // Cutoff based on kurtosis (normalize: typical range 0-10)
            const kurtosisNorm = Math.min((currentFeatures.kurtosis || 0) / 10.0, 1.0);
            const cutoff = featureModConfig.filterCutoffBase * (0.3 + 0.7 * kurtosisNorm);
            
            // Resonance based on skewness (normalize: typical range -2 to 2)
            const skewnessNorm = Math.min(Math.max((currentFeatures.skewness || 0) + 2, 0) / 4.0, 1.0);
            const Q = 1 + (skewnessNorm * featureModConfig.filterResonanceMult);
            
            window.biquadFilter.frequency.setTargetAtTime(cutoff, audioContext.currentTime, 0.01);
            window.biquadFilter.Q.setTargetAtTime(Q, audioContext.currentTime, 0.01);
        }
        
        // Update stereo pan
        function updateStereoPan() {
            if (!gainNode || !isAudioInitialized) {
                return;
            }
            
            // If stereo pan is disabled but exists, remove it
            if (!featureModConfig.stereoPanEnabled && window.stereoPanner) {
                oscillator.disconnect();
                if (window.biquadFilter) {
                    window.biquadFilter.disconnect();
                    oscillator.connect(window.biquadFilter);
                    window.biquadFilter.connect(gainNode);
                } else {
                    oscillator.connect(gainNode);
                }
                window.stereoPanner = null;
                return;
            }
            
            if (!featureModConfig.stereoPanEnabled) {
                return;
            }
            
            // Create panner if it doesn't exist
            if (!window.stereoPanner) {
                window.stereoPanner = audioContext.createStereoPanner();
                // Reconnect: oscillator -> panner -> gain -> destination
                // But we need to handle the filter too if it exists
                oscillator.disconnect();
                if (window.biquadFilter) {
                    oscillator.connect(window.biquadFilter);
                    window.biquadFilter.disconnect();
                    window.biquadFilter.connect(window.stereoPanner);
                    window.stereoPanner.connect(gainNode);
                } else {
                    oscillator.connect(window.stereoPanner);
                    window.stereoPanner.connect(gainNode);
                }
            }
            
            if (!currentFeatures || currentFeatures.spatial_correlation === undefined) {
                window.stereoPanner.pan.value = 0;
                return;
            }
            
            // Pan based on spatial_correlation (normalize: typical range -1 to 1)
            const pan = Math.max(-1, Math.min(1, currentFeatures.spatial_correlation));
            window.stereoPanner.pan.setTargetAtTime(pan, audioContext.currentTime, 0.01);
        }
        
        // Auto-select scale based on features
        function getAutoScale() {
            if (!featureModConfig.autoScaleEnabled || !currentFeatures) {
                return thereminConfig.scale; // Use manual selection
            }
            
            const entropy = currentFeatures.entropy || 0;
            const variance = currentFeatures.variance || 0;
            
            // Combine entropy and variance (both normalized)
            const complexity = (Math.min(entropy / 8.0, 1.0) + Math.min(variance / 10.0, 1.0)) / 2.0;
            
            if (complexity < 0.33) {
                return 'pentatonic';
            } else if (complexity < 0.66) {
                return 'major';
            } else {
                return 'chromatic';
            }
        }
        
        // Tremolo using features
        function updateTremolo() {
            if (!featureModConfig.tremoloEnabled || !gainNode || !isAudioInitialized) {
                // Reset to base volume if tremolo is disabled
                if (gainNode) {
                    gainNode.gain.setTargetAtTime(thereminConfig.volume, audioContext.currentTime, 0.01);
                }
                return;
            }
            
            if (!currentFeatures) {
                return;
            }
            
            const temporalVar = currentFeatures.temporal_delta_variance || 0;
            const spatialGrad = currentFeatures.spatial_gradient || 0;
            
            // Speed based on temporal_delta_variance
            const speed = Math.min(temporalVar * featureModConfig.tremoloSpeed, 20);
            
            // Depth based on spatial_gradient
            const depthNormalized = Math.min(spatialGrad / 5.0, 1.0);
            const depth = depthNormalized * featureModConfig.tremoloDepth;
            
            // Update tremolo phase
            tremoloState.tremoloTime += 1.0 / INTERPOLATION_RATE;
            tremoloState.tremoloPhase = (tremoloState.tremoloPhase + (speed / INTERPOLATION_RATE)) % (2 * Math.PI);
            
            const modulation = Math.sin(tremoloState.tremoloPhase) * depth;
            const baseVolume = thereminConfig.volume;
            const modulatedVolume = baseVolume * (1.0 + modulation);
            const clampedVolume = Math.max(0, Math.min(1, modulatedVolume));
            
            gainNode.gain.setTargetAtTime(clampedVolume, audioContext.currentTime, 0.01);
        }

        // High-frequency interpolation loop
        function startInterpolationLoop() {
            if (interpolationActive) return;
            interpolationActive = true;
            
            const updateInterval = 1000 / INTERPOLATION_RATE; // ~16.67ms for 60Hz
            
            function interpolate() {
                if (!interpolationActive) return;
                
                const now = Date.now();
                const timeSinceLastMQTT = (now - lastUpdateTime) / 1000; // seconds
                
                // If we have a target and it's been less than 2 seconds since last MQTT message
                if (timeSinceLastMQTT < 2.0 && lastUpdateTime > 0) {
                    // Linear interpolation between last and target
                    const interpolationProgress = Math.min(timeSinceLastMQTT * MQTT_RATE, 1.0);
                    const currentMovement = lastMovement + (targetMovement - lastMovement) * interpolationProgress;
                    
                    // Apply exponential smoothing
                    const alpha = thereminConfig.smoothingFactor;
                    smoothedMovement = alpha * currentMovement + (1 - alpha) * smoothedMovement;
                    
                    // Map to frequency
                    const targetFreq = mapMovementToFrequency(smoothedMovement);
                    const movementDelta = Math.abs(targetMovement - lastMovement);
                    const finalFreq = processFrequency(targetFreq, movementDelta);
                    
                    // Update audio
                    if (thereminConfig.enabled) {
                        updateFrequency(finalFreq);
                        // Update tremolo if enabled
                        if (featureModConfig.tremoloEnabled) {
                            updateTremolo();
                        }
                    }
                    
                    // Update UI
                    document.getElementById('movementValue').textContent = smoothedMovement.toFixed(3);
                } else if (lastUpdateTime > 0) {
                    // Use last known value if MQTT is stale, but still apply smoothing
                    const alpha = thereminConfig.smoothingFactor;
                    smoothedMovement = alpha * targetMovement + (1 - alpha) * smoothedMovement;
                    const targetFreq = mapMovementToFrequency(smoothedMovement);
                    const finalFreq = processFrequency(targetFreq, 0);
                    if (thereminConfig.enabled) {
                        updateFrequency(finalFreq);
                    }
                    // Always update tremolo if enabled (even if theremin is disabled, to keep it synced)
                    if (featureModConfig.tremoloEnabled) {
                        updateTremolo();
                    }
                    document.getElementById('movementValue').textContent = smoothedMovement.toFixed(3);
                } else {
                    // No MQTT data yet, but still update tremolo if enabled
                    if (featureModConfig.tremoloEnabled) {
                        updateTremolo();
                    }
                }
                
                setTimeout(interpolate, updateInterval);
            }
            
            interpolate();
        }

        // MQTT Functions
        function toggleConfig() {
            const content = document.getElementById('configContent');
            const arrow = document.getElementById('configArrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        function toggleConnection() {
            if (client && client.connected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const broker = document.getElementById('broker').value;
            const port = document.getElementById('port').value;
            const topic = document.getElementById('topic').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!broker || !port || !topic) {
                alert('Please fill in all required fields!');
                return;
            }

            const connectUrl = `ws://${broker}:${port}/mqtt`;

            const options = {
                clean: true,
                connectTimeout: 4000,
                clientId: 'espectre_theremin_' + Math.random().toString(16).substr(2, 8)
            };

            if (username) options.username = username;
            if (password) options.password = password;

            try {
                client = mqtt.connect(connectUrl, options);

                client.on('connect', () => {
                    console.log('Connected to MQTT broker');
                    updateStatus(true);
                    document.getElementById('configContent').classList.add('collapsed');
                    document.getElementById('configArrow').classList.add('rotate');

                    // Subscribe to main topic
                    client.subscribe(topic, (err) => {
                        if (err) {
                            console.error('Subscribe error:', err);
                            alert('Error subscribing to topic!');
                        } else {
                            console.log('Subscribed to:', topic);
                            resumeAudio();
                            startInterpolationLoop();
                        }
                    });
                });

                client.on('message', (topic, message) => {
                    try {
                        const data = JSON.parse(message.toString());
                        handleMessage(data);
                    } catch (err) {
                        console.error('Error parsing message:', err);
                    }
                });

                client.on('error', (err) => {
                    console.error('Connection error:', err);
                    alert('Connection error: ' + err.message);
                    updateStatus(false);
                });

                client.on('close', () => {
                    console.log('Connection closed');
                    updateStatus(false);
                });

            } catch (err) {
                console.error('Connection error:', err);
                alert('Connection error: ' + err.message);
            }
        }

        function disconnect() {
            if (client) {
                client.end();
                client = null;
                updateStatus(false);
            }
        }

        function updateStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const clearBtn = document.getElementById('clearBtn');

            if (connected) {
                indicator.classList.remove('disconnected');
                indicator.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.textContent = 'Disconnect';
                connectBtn.classList.remove('btn-primary');
                connectBtn.classList.add('btn-danger');
                clearBtn.style.display = 'inline-block';
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
                statusText.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                connectBtn.classList.remove('btn-danger');
                connectBtn.classList.add('btn-primary');
                clearBtn.style.display = 'none';
            }
        }

        function handleMessage(data) {
            // Check if this is a regular data message
            if (data.movement !== undefined || data.threshold !== undefined || data.state) {
                messageCount++;

                // Show/hide Feature Modulation section based on features presence
                const featureSection = document.getElementById('featureModulationSection');
                if (data.features) {
                    // Features are available - show the section
                    featureSection.style.display = 'block';
                    currentFeatures = data.features;
                } else {
                    // No features (e.g., Micro-ESPectre) - hide the section
                    featureSection.style.display = 'none';
                    currentFeatures = null;
                }

                // Update target movement for interpolation
                if (data.movement !== undefined) {
                    lastMovement = targetMovement;
                    targetMovement = data.movement;
                    lastUpdateTime = Date.now();
                    
                    // Initialize smoothedMovement on first message
                    if (smoothedMovement === 0 && targetMovement > 0) {
                        smoothedMovement = targetMovement;
                    }
                }

                // Update tremolo state with packets_processed
                if (data.packets_processed !== undefined) {
                    tremoloState.lastPacketsProcessed = tremoloState.packetsProcessed;
                    tremoloState.packetsProcessed = data.packets_processed;
                }
            }
        }

        // UI Control Functions
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + 'Content');
            const arrow = document.getElementById(sectionId + 'Arrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        // SubSection Toggle Function
        function toggleSubSection(sectionId) {
            const content = document.getElementById(sectionId + 'Content');
            const arrow = document.getElementById(sectionId + 'Arrow');
            content.classList.toggle('collapsed');
            arrow.classList.toggle('rotate');
        }

        function syncSlider(sliderId, valueId) {
            const slider = document.getElementById(sliderId);
            const valueInput = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                valueInput.value = e.target.value;
                updateConfig();
            });

            valueInput.addEventListener('input', (e) => {
                slider.value = e.target.value;
                updateConfig();
            });
        }

        function updateConfig() {
            thereminConfig.enabled = true; // Always enabled
            thereminConfig.mode = document.getElementById('thereminMode').value;
            thereminConfig.scale = document.getElementById('thereminScale').value;
            thereminConfig.baseFrequency = parseFloat(document.getElementById('baseFreqValue').value);
            thereminConfig.frequencyRange = parseFloat(document.getElementById('freqRangeValue').value);
            thereminConfig.smoothingFactor = parseFloat(document.getElementById('smoothingValue').value) / 100;
            thereminConfig.volume = parseFloat(document.getElementById('volumeValue').value) / 100;
            thereminConfig.maxMovement = parseFloat(document.getElementById('maxMovementValue').value);
            thereminConfig.logarithmicMapping = document.getElementById('logarithmicMapping').checked;

            // Feature modulation config
            featureModConfig.waveformEnabled = document.getElementById('waveformModEnable').checked;
            featureModConfig.vibratoEnabled = document.getElementById('vibratoModEnable').checked;
            featureModConfig.vibratoSpeedMult = parseFloat(document.getElementById('vibratoSpeedValue').value);
            featureModConfig.vibratoDepthMult = parseFloat(document.getElementById('vibratoDepthValue').value);
            featureModConfig.filterEnabled = document.getElementById('filterModEnable').checked;
            featureModConfig.filterCutoffBase = parseFloat(document.getElementById('filterCutoffValue').value);
            featureModConfig.filterResonanceMult = parseFloat(document.getElementById('filterResonanceValue').value);
            featureModConfig.stereoPanEnabled = document.getElementById('stereoPanEnable').checked;
            featureModConfig.autoScaleEnabled = document.getElementById('autoScaleEnable').checked;
            featureModConfig.tremoloEnabled = document.getElementById('tremoloEnable').checked;
            featureModConfig.tremoloSpeed = parseFloat(document.getElementById('tremoloSpeedValue').value);
            featureModConfig.tremoloDepth = parseFloat(document.getElementById('tremoloDepthValue').value) / 100;
            featureModConfig.effectsEnabled = document.getElementById('effectsModEnable').checked;

            // Update audio volume (tremolo will modulate it if enabled)
            if (gainNode) {
                if (!thereminConfig.enabled) {
                    gainNode.gain.value = 0;
                } else if (!featureModConfig.tremoloEnabled) {
                    gainNode.gain.value = thereminConfig.volume;
                }
                // If tremolo is enabled, it will be updated in the interpolation loop
            }
        }

        function clearData() {
            messageCount = 0;
            document.getElementById('movementValue').textContent = '-';
            document.getElementById('frequencyValue').textContent = '-';
            document.getElementById('currentNote').textContent = '-';
            document.getElementById('octaveOrFeature').textContent = '-';
            document.getElementById('featureLabel').textContent = 'Octave';
            
            // Reset theremin state
            lastMovement = 0;
            targetMovement = 0;
            smoothedMovement = 0;
            lastUpdateTime = 0;
            currentFeatures = null;
            
            // Reset audio if initialized
            if (oscillator && isAudioInitialized) {
                oscillator.frequency.setTargetAtTime(thereminConfig.baseFrequency, audioContext.currentTime, 0.01);
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Initialize on load
        window.addEventListener('load', () => {
            // Sync sliders
            syncSlider('baseFreq', 'baseFreqValue');
            syncSlider('freqRange', 'freqRangeValue');
            syncSlider('smoothing', 'smoothingValue');
            syncSlider('volume', 'volumeValue');
            syncSlider('maxMovement', 'maxMovementValue');
            syncSlider('tremoloSpeed', 'tremoloSpeedValue');
            syncSlider('tremoloDepth', 'tremoloDepthValue');
            syncSlider('vibratoSpeed', 'vibratoSpeedValue');
            syncSlider('vibratoDepth', 'vibratoDepthValue');
            syncSlider('filterCutoff', 'filterCutoffValue');
            syncSlider('filterResonance', 'filterResonanceValue');

            // Setup event listeners
            document.getElementById('thereminMode').addEventListener('change', updateConfig);
            document.getElementById('thereminScale').addEventListener('change', updateConfig);
            document.getElementById('logarithmicMapping').addEventListener('change', updateConfig);
            
            // Feature modulation event listeners
            document.getElementById('waveformModEnable').addEventListener('change', updateConfig);
            document.getElementById('vibratoModEnable').addEventListener('change', updateConfig);
            document.getElementById('filterModEnable').addEventListener('change', updateConfig);
            document.getElementById('stereoPanEnable').addEventListener('change', updateConfig);
            document.getElementById('autoScaleEnable').addEventListener('change', updateConfig);
            document.getElementById('tremoloEnable').addEventListener('change', updateConfig);
            document.getElementById('effectsModEnable').addEventListener('change', updateConfig);

            // Initialize audio on user interaction
            document.addEventListener('click', () => {
                if (!isAudioInitialized) {
                    initAudio();
                }
            }, { once: true });

            // Initialize config
            updateConfig();
        });
    </script>
</body>

</html>
